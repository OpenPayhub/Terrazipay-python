{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"x402_mock","text":"<p>A production-grade Python module implementing the HTTP 402 Payment Required workflow.</p>"},{"location":"#overview","title":"Overview","text":"<p><code>x402_mock</code> seamlessly integrates Web2 HTTP protocol with Web3 on-chain payments, enabling automated payment workflows based on the HTTP 402 status code.</p> <p>Core Tech Stack: - Web3 + USDC (ERC20) - EIP-2612 Permit signatures (gas-less approval) - Asynchronous on-chain settlement</p> <p>Payment Flow: <pre><code>Client (Requester) \u2192 Server (Recipient) \u2192 On-chain Settlement\n</code></pre></p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Standardized payment protocol based on HTTP 402</li> <li>\u2705 EIP-2612 Permit signature, no pre-approval required</li> <li>\u2705 Asynchronous on-chain settlement without blocking business flow</li> <li>\u2705 Multiple payment method negotiation and matching</li> <li>\ud83e\udd16 Designed for Agent-to-Agent automated payment scenarios</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This project uses <code>uv</code> as the package management tool.</p> <pre><code>uv add x402-mock\nuv sync\n</code></pre>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env</code> file in the project root:</p> <pre><code>EVM_PRIVATE_KEY=your_private_key_here\nEVM_INFURA_KEY=your_infura_key_here  # Optional\n</code></pre> <p>Required: - <code>EVM_PRIVATE_KEY</code> - Wallet private key for signing and on-chain transactions</p> <p>Optional: - <code>EVM_INFURA_KEY</code> - Infura API Key (uses public nodes if not provided)</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#server-example","title":"Server Example","text":"<pre><code>from x402_mock.servers import Http402Server, create_private_key\n\ntoken_key = create_private_key()\napp = Http402Server(token_key=token_key, token_expires_in=300)\n\napp.add_payment_method(\n    chain_id=\"eip155:11155111\",\n    amount=0.5,\n    currency=\"USDC\",\n)\n\n@app.get(\"/api/protected-data\")\n@app.payment_required\nasync def get_protected_data(authorization):\n    return {\"message\": \"Payment verified successfully\"}\n</code></pre>"},{"location":"#client-example","title":"Client Example","text":"<pre><code>from x402_mock.clients.http_client import Http402Client\n\nasync with Http402Client() as client:\n    client.add_payment_method(\n        chain_id=\"eip155:11155111\",\n        amount=0.8,\n        currency=\"USDC\"\n    )\n    response = client.get(\"http://localhost:8000/api/protected-data\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Check the API Reference for detailed documentation</li> <li>See the GitHub Repository for more examples</li> <li>Source Code: <code>/src/terrazip/x402_mock/</code> in the main repository</li> <li>\u26a0\ufe0f Test on testnet (e.g., Sepolia) before production use</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Comprehensive API documentation for x402_mock module.</p>"},{"location":"reference/#servers","title":"Servers","text":"<p>HTTP 402 Payment Protocol Server Implementation</p> <p>The Servers module provides a FastAPI-based server framework for implementing HTTP 402 Payment Required protocol. It offers an event-driven architecture that encapsulates all payment collection logic, allowing payment receivers to integrate cryptocurrency payment acceptance with minimal configuration.</p> <p>Key Features: - FastAPI Integration: Extended FastAPI application with built-in payment endpoint routes - Token Management: Secure JWT-based access token generation and verification - Event-Driven Architecture: Subscribe to payment lifecycle events (request, verification, settlement) - Multi-Chain Support: Register multiple payment methods across different blockchain networks - Auto-Settlement: Optional automatic on-chain settlement after successful verification - Security Utilities: Private key generation, token signing, and environment key management</p> <p>Main Components: - <code>Http402Server</code>: Main server class extending FastAPI with payment protocol support - Security helpers: <code>generate_token()</code>, <code>verify_token()</code>, <code>create_private_key()</code>, <code>save_key_to_env()</code></p>"},{"location":"reference/#x402_mock.servers","title":"<code>x402_mock.servers</code>","text":""},{"location":"reference/#x402_mock.servers.Http402Server","title":"<code>Http402Server</code>","text":"<p>               Bases: <code>FastAPI</code></p> <p>FastAPI server with X402 payment protocol support.</p>"},{"location":"reference/#x402_mock.servers.Http402Server.__init__","title":"<code>__init__(token_key: str, adapter_hub: Optional[AdapterHub] = None, token_expires_in: int = 3600, enable_auto_settlement: bool = True, token_endpoint: str = '/token', **fastapi_kwargs)</code>","text":"<p>Initialize X402 payment server.</p> <p>Parameters:</p> Name Type Description Default <code>token_key</code> <code>str</code> <p>Secret key for signing access tokens</p> required <code>adapter_hub</code> <code>Optional[AdapterHub]</code> <p>Payment adapter hub (default: new instance)</p> <code>None</code> <code>token_expires_in</code> <code>int</code> <p>Token lifetime in seconds (default: 3600)</p> <code>3600</code> <code>enable_auto_settlement</code> <code>bool</code> <p>Auto-settle after verification (default: True)</p> <code>True</code> <code>token_endpoint</code> <code>str</code> <p>Token endpoint path (default: /token)</p> <code>'/token'</code> <code>**fastapi_kwargs</code> <p>FastAPI arguments (title, version, etc.)</p> <code>{}</code>"},{"location":"reference/#x402_mock.servers.Http402Server.add_payment_method","title":"<code>add_payment_method(chain_id: str, amount: float, currency: str) -&gt; None</code>","text":"<p>Register a payment method.</p> <p>Parameters:</p> Name Type Description Default <code>chain_id</code> <code>str</code> <p>Chain identifier (e.g., \"eip155:1\")</p> required <code>amount</code> <code>float</code> <p>Payment amount</p> required <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USDC\")</p> required"},{"location":"reference/#x402_mock.servers.Http402Server.subscribe","title":"<code>subscribe(event_class: type[BaseEvent], handler: Callable) -&gt; None</code>","text":"<p>Register event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to handle</p> required <code>handler</code> <code>Callable</code> <p>Async function(event, deps) -&gt; Optional[BaseEvent]</p> required Example <pre><code>async def my_handler(event: TokenIssuedEvent, deps: Dependencies):\n    # Custom logic\n    return None  # or return another event\n\napp.subscribe(TokenIssuedEvent, my_handler)\n</code></pre>"},{"location":"reference/#x402_mock.servers.Http402Server.add_hook","title":"<code>add_hook(event_class: type[BaseEvent], hook: Callable) -&gt; None</code>","text":"<p>Register event hook for side effects.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to hook into</p> required <code>hook</code> <code>Callable</code> <p>Async function(event, deps) -&gt; None</p> required Example <pre><code>async def log_event(event, deps):\n    print(f\"Event: {event}\")\n\napp.add_hook(TokenIssuedEvent, log_event)\n</code></pre>"},{"location":"reference/#x402_mock.servers.Http402Server.hook","title":"<code>hook(event_class: type[BaseEvent]) -&gt; Callable</code>","text":"<p>Decorator for registering event hooks.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>Event type to hook into</p> required Example <p>@app.hook(TokenIssuedEvent) async def on_token_issued(event, deps):     await send_analytics(event)</p>"},{"location":"reference/#x402_mock.servers.Http402Server.payment_required","title":"<code>payment_required(route_handler)</code>","text":"<p>Decorator to protect routes with payment verification.</p> <p>Returns 402 response if payment required, otherwise executes handler with verified payload.</p> Example <pre><code>@app.payment_required\n@app.get(\"/data\")\nasync def get_data(payload):\n    return {\"user\": payload[\"address\"]}\n</code></pre>"},{"location":"reference/#x402_mock.servers.generate_token","title":"<code>generate_token(*, private_key: str, expires_in: int = 3600, nonce_length: int = 16) -&gt; str</code>","text":"<p>Generate a signed token.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>str</code> <p>Secret key used to sign the token.</p> required <code>expires_in</code> <code>int</code> <p>Token lifetime in seconds.</p> <code>3600</code> <code>nonce_length</code> <code>int</code> <p>Length of random nonce.</p> <code>16</code> <p>Returns:</p> Type Description <code>str</code> <p>Signed token string.</p>"},{"location":"reference/#x402_mock.servers.verify_token","title":"<code>verify_token(*, token: str, private_key: str, leeway: int = 0) -&gt; Dict[str, object]</code>","text":"<p>Verify token signature and expiration.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token string.</p> required <code>private_key</code> <code>str</code> <p>Secret key used to verify the token.</p> required <code>leeway</code> <code>int</code> <p>Allowed clock skew in seconds.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dict[str, object]</code> <p>Decoded payload if valid.</p> <p>Raises:</p> Type Description <code>TokenExpired</code> <p>If token is expired.</p> <code>TokenInvalid</code> <p>If token is malformed or signature mismatch.</p>"},{"location":"reference/#x402_mock.servers.create_private_key","title":"<code>create_private_key(*, prefix: str = '', length: int = 32, use_special_chars: bool = False) -&gt; str</code>","text":"<p>Generate a private key with optional prefix and randomization rules.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>A custom string to prepend to the random key (semi-automatic rule).</p> <code>''</code> <code>length</code> <code>int</code> <p>The number of random characters to generate.</p> <code>32</code> <code>use_special_chars</code> <code>bool</code> <p>Whether to include special characters in the random part.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A secure private key string.</p>"},{"location":"reference/#x402_mock.servers.save_key_to_env","title":"<code>save_key_to_env(key_name: str, key_value: str, env_file: str = '.env')</code>","text":"<p>Save or update a key-value pair in a .env file.</p> <p>Parameters:</p> Name Type Description Default <code>key_name</code> <code>str</code> <p>The environment variable name (e.g., \"PRIVATE_KEY\").</p> required <code>key_value</code> <code>str</code> <p>The actual key string to save.</p> required <code>env_file</code> <code>str</code> <p>Path to the .env file. Defaults to \".env\".</p> <code>'.env'</code>"},{"location":"reference/#clients","title":"Clients","text":"<p>HTTP 402 Payment Client Middleware</p> <p>The Clients module provides an intelligent HTTP client that transparently handles HTTP 402 Payment Required responses. It extends <code>httpx.AsyncClient</code> to automatically intercept payment challenges, generate signed payment permits, exchange them for access tokens, and retry the original request\u2014all without requiring explicit user intervention.</p> <p>Key Features: - Transparent Payment Handling: Automatically processes 402 responses without manual intervention - httpx Compatibility: Fully compatible drop-in replacement for httpx.AsyncClient - Permit Auto-Signing: Generates blockchain-specific signed permits using registered payment methods - Token Exchange: Automatically exchanges permits for access tokens at server endpoints - Request Retry: Seamlessly retries original requests with obtained authorization - Multi-Chain Support: Register payment capabilities across different blockchain networks</p> <p>Main Components: - <code>Http402Client</code>: Extended async HTTP client with automatic payment flow handling</p> <p>Usage Pattern: 1. Initialize client and register payment methods 2. Make standard HTTP requests to protected resources 3. Client automatically handles 402 challenges and obtains access 4. Receive successful responses transparently</p>"},{"location":"reference/#x402_mock.clients","title":"<code>x402_mock.clients</code>","text":"<p>Client module for x402 payment authorization.</p> <p>Provides easy-to-use interfaces for accessing protected resources with automatic permit signing and token exchange.</p>"},{"location":"reference/#x402_mock.clients.Http402Client","title":"<code>Http402Client</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>Extended httpx.AsyncClient with automatic 402 payment handling.</p> <p>This client extends httpx.AsyncClient and automatically handles 402 Payment  Required status codes by: 1. Parsing payment requirements 2. Generating signed permits 3. Exchanging permits for access tokens 4. Retrying the original request with authorization</p> <p>Fully compatible with httpx.AsyncClient - supports all methods, properties, and can be used as an async context manager.</p> Usage <pre><code>async with Http402Client() as client:\n    client.add_payment_method(\"eip155:11155111\", 100.0, \"USDC\")\n    response = await client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"reference/#x402_mock.clients.Http402Client.__init__","title":"<code>__init__(adapter_hub: Optional[AdapterHub] = None, **kwargs)</code>","text":"<p>Initialize client with optional payment adapter.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_hub</code> <code>Optional[AdapterHub]</code> <p>Optional AdapterHub for payment handling</p> <code>None</code> <code>token</code> <p>Optional initial authorization token</p> required <code>**kwargs</code> <p>All standard httpx.AsyncClient arguments (timeout, headers, etc.)</p> <code>{}</code>"},{"location":"reference/#x402_mock.clients.Http402Client.add_payment_method","title":"<code>add_payment_method(chain_id: str, amount: float, currency: str) -&gt; None</code>","text":"<p>Register local payment capability.</p> <p>This enables the middleware to automatically generate payment permits when encountering 402 responses.</p> <p>Parameters:</p> Name Type Description Default <code>chain_id</code> <code>str</code> <p>Blockchain identifier (e.g., \"eip155:11155111\")</p> required <code>amount</code> <code>float</code> <p>Maximum payment amount supported</p> required <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USDC\")</p> required"},{"location":"reference/#x402_mock.clients.Http402Client.request","title":"<code>request(method: str, url: httpx._types.URLTypes, **kwargs) -&gt; httpx.Response</code>  <code>async</code>","text":"<p>Execute HTTP request with automatic 402 handling.</p> <p>Overrides httpx.AsyncClient.request() to intercept 402 responses. All other httpx methods (get, post, etc.) automatically use this.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method (GET, POST, etc.)</p> required <code>url</code> <code>URLTypes</code> <p>Request URL</p> required <code>**kwargs</code> <p>All standard httpx arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>httpx.Response object</p>"},{"location":"reference/#adapters","title":"Adapters","text":"<p>Unified Blockchain Adapter Interface</p> <p>The Adapters module provides a unified abstraction layer that bridges differences between various blockchain platforms (EVM, Solana, etc.). It implements a plugin-based architecture with automatic blockchain type detection, enabling consistent payment permit signing, signature verification, and on-chain settlement operations across heterogeneous blockchain ecosystems.</p> <p>Key Features: - Blockchain Abstraction: Unified interface for EVM, SVM (Solana), and other blockchain platforms - Automatic Type Detection: Identifies blockchain type from chain identifiers (CAIP-2 format) - Signature Operations: Generate and verify blockchain-specific cryptographic signatures - Permit Validation: Verify permit authenticity, expiration, nonce, and on-chain conditions - Transaction Settlement: Execute on-chain transfers with confirmation tracking - Balance Queries: Query token balances and allowances across different chains - Extensible Architecture: Factory pattern enables easy addition of new blockchain adapters</p> <p>Main Components: - <code>AdapterHub</code>: Central gateway routing operations to appropriate blockchain adapters - <code>AdapterFactory</code>: Abstract base class defining adapter interface contracts - <code>PaymentRegistry</code>: Manages payment method registration and retrieval - Platform-specific adapters: <code>EVMAdapter</code> (Ethereum/EVM chains), SVM adapter (coming soon)</p> <p>Architecture Pattern: Uses the Adapter pattern combined with Factory pattern to provide a consistent API while delegating to blockchain-specific implementations under the hood.</p>"},{"location":"reference/#x402_mock.adapters","title":"<code>x402_mock.adapters</code>","text":""},{"location":"reference/#x402_mock.adapters.AdapterHub","title":"<code>AdapterHub</code>","text":"<p>Unified Blockchain Adapter Hub.</p> <p>Provides core blockchain adapter operations with automatic type detection and routing. Manages payment component registration and delegates to blockchain-specific adapters.</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.__init__","title":"<code>__init__(evm_private_key: str = None, rpc_url: Optional[str] = None, request_timeout: int = 60)</code>","text":"<p>Initialize AdapterHub with registry and adapter mappings.</p> <p>Sets up payment registry and registers EVM adapter with BlockchainDetector.</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.register_payment_methods","title":"<code>register_payment_methods(chain_id: str, amount: float, currency: str) -&gt; None</code>","text":"<p>Register payment methods for a specific chain.</p> <p>Automatically detects blockchain type from chain_id and obtains wallet address.</p> <p>Parameters:</p> Name Type Description Default <code>chain_id</code> <code>str</code> <p>Chain ID in CAIP-2 format (e.g., \"eip155:1\" for EVM)</p> required <code>amount</code> <code>float</code> <p>Payment amount</p> required <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USD\")</p> required"},{"location":"reference/#x402_mock.adapters.AdapterHub.get_payment_methods","title":"<code>get_payment_methods() -&gt; List[PaymentComponentTypes]</code>","text":"<p>Get all registered payment methods.</p> <p>Returns:</p> Type Description <code>List[PaymentComponentTypes]</code> <p>List of registered payment components</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.verify_signature","title":"<code>verify_signature(permit_payload: Union[PermitTypes, Dict[str, Any]]) -&gt; Optional[Any]</code>  <code>async</code>","text":"<p>Verify permit signature with automatic blockchain detection and component matching.</p> <p>Converts permit payload to typed model, matches token with registered components, and calls corresponding adapter to verify signature.</p> <p>Parameters:</p> Name Type Description Default <code>permit_payload</code> <code>Union[PermitTypes, Dict[str, Any]]</code> <p>Permit data (PermitTypes or dict)</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Verification result from adapter</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If blockchain type cannot be determined</p> <code>ValueError</code> <p>If payload conversion or token matching fails</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.settle","title":"<code>settle(permit_payload: Union[PermitTypes, Dict[str, Any]]) -&gt; Optional[Any]</code>  <code>async</code>","text":"<p>Execute permit settlement with automatic type conversion.</p> <p>Converts permit payload to typed model and calls corresponding adapter.</p> <p>Parameters:</p> Name Type Description Default <code>permit_payload</code> <code>Union[PermitTypes, Dict[str, Any]]</code> <p>Permit data (PermitTypes or dict)</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Transaction confirmation from server adapter</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If blockchain type cannot be determined</p> <code>ValueError</code> <p>If payload conversion fails</p>"},{"location":"reference/#x402_mock.adapters.AdapterHub.signature","title":"<code>signature(list_components: List[Union[PaymentComponentTypes, Dict[str, Any]]]) -&gt; PermitTypes</code>  <code>async</code>","text":"<p>Generate signed permit from remote payment components.</p> <p>Matches remote components against local support list, converts to typed model, and delegates to blockchain-specific adapter for signing.</p> <p>Parameters:</p> Name Type Description Default <code>list_components</code> <code>List[Union[PaymentComponentTypes, Dict[str, Any]]]</code> <p>Remote payment components (typed or dict) to match</p> required <p>Returns:</p> Type Description <code>PermitTypes</code> <p>Signed permit from adapter</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no matching component found or conversion fails</p> <code>TypeError</code> <p>If blockchain type cannot be determined</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry","title":"<code>PaymentRegistry</code>","text":"<p>Registry for creating blockchain-specific payment components.</p> <p>Maps blockchain types to their payment component factories and manages creation of payment components for different chains.</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry.method_register","title":"<code>method_register(chain_id: str, amount: float, currency: str, wallet_address: str) -&gt; None</code>","text":"<p>Create payment components for a specific chain.</p> <p>Parameters:</p> Name Type Description Default <code>chain_id</code> <code>str</code> <p>Chain identifier in CAIP-2 format (e.g., \"eip155:1\", \"eip155:11155111\")</p> required <code>amount</code> <code>float</code> <p>Payment amount in smallest units (e.g., 1.0 USDC)</p> required <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USD\", \"EUR\")</p> required <code>wallet_address</code> <code>str</code> <p>Wallet address for permit signing</p> required <p>Returns:</p> Type Description <code>None</code> <p>List of initialized payment components, or None if chain not supported</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input parameters are invalid</p> Example <p>components = BlockchainPaymentRegistry.create_payment_components(     chain_id=\"eip155:1\",     amount=1.0,     currency=\"USD\" )</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry.method_register--returns-evmpaymentcomponent","title":"Returns: [EVMPaymentComponent(...), ...]","text":""},{"location":"reference/#x402_mock.adapters.PaymentRegistry.get_support_list","title":"<code>get_support_list() -&gt; List[PaymentComponentTypes]</code>","text":"<p>Get all registered payment components.</p> <p>Returns:</p> Type Description <code>List[PaymentComponentTypes]</code> <p>List of all registered payment components</p> Example <p>registry = PaymentRegistry() registry.method_register(\"eip155:1\", 1.0, \"USD\") components = registry.get_support_list()</p>"},{"location":"reference/#x402_mock.adapters.PaymentRegistry.get_support_list--returns-evmpaymentcomponent","title":"Returns: [EVMPaymentComponent(...), ...]","text":""},{"location":"reference/#x402_mock.adapters.AdapterFactory","title":"<code>AdapterFactory</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract Base Class for Server-Side Blockchain Adapters.</p> <p>Defines the interface for server-side operations that interact directly with blockchain nodes. Server-side adapters are responsible for: - Verifying permit signatures and permit validity on-chain - Executing transactions (settle/send_transaction) on-chain - Querying token balances and other on-chain state</p> <p>Server adapters use the application's private key to sign and send transactions. They act as the bridge between the x402 system and the blockchain.</p> <p>Key Responsibilities: 1. verify_signature: Validate permit signature and check permit conditions on-chain 2. settle: Execute the permit transaction on-chain and return confirmation 3. get_balance: Query token balance of an address on-chain 4. signature: Support signing operations for blockchain-specific formats</p> Example Implementation <p>class EVMServerAdapter(AdapterServerFactory):     # EVM/Ethereum-specific implementation     pass</p> <p>class SolanaServerAdapter(AdapterServerFactory):     # Solana-specific implementation     pass</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.verify_signature","title":"<code>verify_signature(permit: BasePermit, payment_requirement: BasePaymentComponent) -&gt; BaseVerificationResult</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Verify permit signature validity and check permit conditions on-chain.</p> <p>This is the critical security operation that ensures: 1. The permit signature is cryptographically valid 2. The recovered signer matches the permit owner 3. The permit has not expired 4. The nonce prevents replay attacks 5. The owner has sufficient balance and allowance 6. The payment amount matches or exceeds requirements</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>BasePermit</code> <p>BasePermit instance containing permit data and signature</p> required <code>payment_requirement</code> <code>BasePaymentComponent</code> <p>BasePaymentComponent specifying expected payment amount/conditions</p> required <p>Returns:</p> Name Type Description <code>BaseVerificationResult</code> <code>BaseVerificationResult</code> <p>Detailed verification result including: - status: Verification result status (SUCCESS, INVALID_SIGNATURE, EXPIRED, etc.) - is_valid: Boolean indicating if permit is valid - permit_owner: Verified owner address - authorized_amount: Verified authorized amount - message: Human-readable status message - blockchain_state: Optional on-chain state data</p> Implementation Notes <ul> <li>Must recover the signer from signature</li> <li>Must verify signature against permit data hash</li> <li>Must check permit.is_expired()</li> <li>Must query on-chain state (nonce, allowance, balance)</li> <li>Must validate payment amount meets requirements</li> </ul> Example <p>result = await adapter.verify_signature(permit, payment_req) if result.is_success():     # Permit is valid, proceed to settlement     await adapter.settle(permit) else:     # Return verification error to client     error_msg = result.get_error_message()</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.settle","title":"<code>settle(permit: BasePermit) -&gt; BaseTransactionConfirmation</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute permit transaction on-chain (settlement/transaction execution).</p> <p>This method actually executes the token transfer on-chain using the permit signature. It should only be called after verify_signature has confirmed the permit is valid.</p> <p>Steps: 1. Construct permit() call with signature components (v, r, s) 2. Build the complete transaction (gas estimation, nonce, etc.) 3. Sign transaction with server's private key 4. Broadcast transaction to blockchain 5. Wait for transaction confirmation 6. Return transaction confirmation with hash and receipt data</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>BasePermit</code> <p>BasePermit instance with valid signature (assumed verified)</p> required <p>Returns:</p> Name Type Description <code>BaseTransactionConfirmation</code> <code>BaseTransactionConfirmation</code> <p>Transaction execution result including: - status: Transaction status (SUCCESS, FAILED, PENDING, etc.) - tx_hash: Transaction hash on-chain - block_number: Block number containing transaction - block_timestamp: Block timestamp - gas_used: Actual gas consumed - confirmations: Number of block confirmations - error_message: Error details if transaction failed</p> Implementation Notes <ul> <li>Estimate gas before sending</li> <li>Sign transaction with server private key</li> <li>Handle blockchain-specific transaction formats</li> <li>Wait for configurable number of confirmations</li> <li>Handle network errors gracefully</li> </ul> Example <p>result = await adapter.settle(permit) if result.is_success():     print(f\"Settlement complete: {result.tx_hash}\")     # Update database with tx_hash else:     print(f\"Settlement failed: {result.error_message}\")</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_balance","title":"<code>get_balance(address: str) -&gt; int</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Query token balance for an address on the blockchain.</p> <p>Retrieves the current balance of the configured token (typically USDC) for the given address. This is used for: - Verification: Check owner has sufficient balance - Queries: Allow clients to check addresses' balances</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Wallet address to query (blockchain format, e.g., \"0x...\" for EVM)</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Token balance in smallest units (e.g., wei for EVM where 1 USDC = 1e6)  Returns 0 if address has no balance</p> Implementation Notes <ul> <li>Use blockchain node RPC call (balanceOf for ERC20)</li> <li>Handle address validation/checksum</li> <li>Cache results if possible for performance</li> <li>Handle blockchain-specific address formats</li> </ul> Example <p>balance = await adapter.get_balance(\"0x1234...5678\")</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_balance--balance-1000000-representing-1-usdc-with-6-decimals","title":"balance = 1000000 (representing 1 USDC with 6 decimals)","text":""},{"location":"reference/#x402_mock.adapters.AdapterFactory.signature","title":"<code>signature(payment_component: BasePaymentComponent) -&gt; BasePermit</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Generate complete signed permit from payment component.</p> <p>This method builds the permit message, signs it with user's private key/wallet, and returns a fully signed and ready-to-submit permit object. All permit parameters are derived from the payment_component.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>BasePaymentComponent</code> <p>BasePaymentComponent specifying payment requirements,                blockchain type, and all permit parameters</p> required <p>Returns:</p> Name Type Description <code>BasePermit</code> <code>BasePermit</code> <p>Fully signed permit ready for server submission. For EVM, this is EIP2612Permit with: - owner: Token owner address - spender: Authorized spender address - token: Token contract address - value: Authorized amount - deadline: Permit expiration timestamp - nonce: Replay attack prevention nonce - signature: EIP2612PermitSignature with v, r, s components - permit_type: Blockchain-specific type (e.g., \"EIP2612\")</p> Implementation Notes <ul> <li>Extract all permit parameters from payment_component</li> <li>Must validate payment_component matches the adapter's blockchain type</li> <li>Must build blockchain-specific permit message internally</li> <li>Must sign with user's private key (not server's)</li> <li>Must validate signature format before returning</li> <li>Must return complete permit with signature components</li> <li>Should not leak private key</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If payment_component blockchain type doesn't match adapter</p> <code>ValueError</code> <p>If payment_component is invalid or signing fails</p> Example <p>adapter = EVMClientAdapter() payment = EVMPaymentComponent(payment_type=\"evm\", ...) permit = await adapter.signature(payment_component=payment)</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.signature--permit-now-contains-complete-signed-data-ready-to-send-to-server","title":"permit now contains complete signed data ready to send to server","text":"<p>await server.settle(permit)</p>"},{"location":"reference/#x402_mock.adapters.AdapterFactory.get_wallet_address","title":"<code>get_wallet_address() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get server wallet address from private key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Server wallet address in checksum format</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter","title":"<code>EVMAdapter</code>","text":"<p>               Bases: <code>AdapterFactory</code></p> <p>EVM Blockchain Server Adapter Implementation.</p> <p>Provides complete server-side functionality for EVM blockchains including: - EIP2612 permit signature verification - On-chain state validation (nonce, allowance, balance, expiration) - Token transfer execution via signed permits - Balance and allowance queries</p> <p>This adapter validates all security constraints before executing any on-chain operations. All methods are designed to return clear, actionable error messages rather than raising exceptions.</p> <p>Key Design Features: - Dynamic RPC URL selection based on permit's chain_id - Environment-aware infrastructure key handling (evm_infra_key for premium RPC, falls back to public) - Private key loaded from environment (evm_private_key) during initialization - Lazy Web3 instance creation per blockchain interaction (ensures correct RPC endpoint)</p> <p>Attributes:</p> Name Type Description <code>account</code> <p>Server's account object (initialized from evm_private_key environment variable)</p> <code>address</code> <p>Checksum-formatted server account address</p> <code>_infra_key</code> <p>Optional infrastructure API key for premium RPC endpoints</p> Environment Variables <ul> <li>evm_private_key: Server's EVM private key for signing transactions (required)</li> <li>evm_infra_key: Optional infrastructure API key (e.g., Alchemy/Infura key)                 If not set, falls back to public RPC endpoints</li> </ul> Example"},{"location":"reference/#x402_mock.adapters.EVMAdapter--initialize-with-environment-variables","title":"Initialize with environment variables","text":"<p>adapter = EVMServerAdapter()  # Loads evm_private_key automatically</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter--or-explicitly-provide-private-key-for-testing","title":"Or explicitly provide private key (for testing)","text":"<p>adapter = EVMServerAdapter(private_key=\"0x...\")</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter--verify-permit-signature-and-on-chain-state","title":"Verify permit signature and on-chain state","text":"<p>result = await adapter.verify_signature(permit, payment_requirement) if result.is_success():     # Execute the permit on-chain     confirmation = await adapter.settle(permit)</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.__init__","title":"<code>__init__(private_key: Optional[str] = None, rpc_url: Optional[str] = None, request_timeout: int = 60)</code>","text":"<p>Initialize EVM Server Adapter with environment-aware configuration.</p> <p>This constructor implements a flexible initialization pattern: 1. Accepts optional private_key parameter (useful for testing) 2. Falls back to evm_private_key environment variable if not provided 3. Initializes server account from the resolved private key 4. Loads optional infrastructure key from evm_infra_key environment variable</p> <p>Token address and RPC URL are NOT stored at initialization time. Instead, they are derived dynamically from the permit object during verify_signature() and settle() calls. This allows the adapter to handle multiple tokens and networks seamlessly.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>Optional[str]</code> <p>Optional server's private key (0x-prefixed hex format) for explicit override.         If None, loads from evm_private_key environment variable.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither private_key parameter nor evm_private_key environment variable        are provided, or if the private key format is invalid.</p> Note <p>The adapter stores the infra_key from environment but constructs RPC URLs dynamically based on chain_id from the permit. This enables efficient multi-chain support.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.signature","title":"<code>signature(payment_component: EVMPaymentComponent) -&gt; EIP2612Permit</code>  <code>async</code>","text":"<p>Generate complete signed EIP2612 permit from payment component.</p> <p>Parameters:</p> Name Type Description Default <code>payment_component</code> <code>EVMPaymentComponent</code> <p>EVMPaymentComponent with permit parameters</p> required <p>Returns:</p> Name Type Description <code>EIP2612Permit</code> <code>EIP2612Permit</code> <p>Fully signed permit ready for server submission</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If payment_component is invalid or signing fails</p> <code>TypeError</code> <p>If private_key is not available</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.verify_signature","title":"<code>verify_signature(permit: EIP2612Permit, payment_requirement: EVMPaymentComponent) -&gt; EVMVerificationResult</code>  <code>async</code>","text":"<p>Verify EIP2612 permit signature and validate all security constraints.</p> <p>Performs comprehensive validation: 1. Verify permit data structure (EIP2612Permit format) 2. Recover signer from ECDSA signature 3. Verify recovered signer matches permit owner 4. Check permit deadline has not expired 5. Query on-chain nonce and verify no replay attack 6. Query on-chain allowance and verify it covers required amount 7. Query token balance and verify owner has sufficient funds 8. Verify spender address matches server address</p> <p>Dynamic Chain Handling: - Automatically obtains Web3 instance for the correct blockchain using permit.chain_id - Constructs RPC URL with infrastructure key handling (premium RPC if available, fallback to public) - No chain configuration needed beyond what's in the permit</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>EIP2612Permit</code> <p>BasePermit instance (must be EIP2612Permit with chain_id)</p> required <code>payment_requirement</code> <code>EVMPaymentComponent</code> <p>BasePaymentComponent specifying expected payment</p> required <p>Returns:</p> Name Type Description <code>EVMVerificationResult</code> <code>EVMVerificationResult</code> <p>Comprehensive verification result including: - status: Overall verification status - is_valid: Boolean success indicator - permit_owner: Verified owner address if successful - authorized_amount: Verified authorized amount if successful - message: Human-readable status message - error_details: Specific error information if failed - on_chain_nonce: Current on-chain nonce - on_chain_allowance: Current on-chain allowance - owner_balance: Current token balance of owner</p> Note <p>This method does NOT raise exceptions. All errors are returned in the result object. The chain_id and token address are extracted from the permit automatically.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.settle","title":"<code>settle(permit: EIP2612Permit) -&gt; EVMTransactionConfirmation</code>  <code>async</code>","text":"<p>Execute permit transaction on-chain to settle token transfer.</p> <p>This method: 1. Constructs permit() call with signature components 2. Builds transaction with gas estimation 3. Signs transaction with server private key 4. Broadcasts to blockchain network 5. Waits for confirmation 6. Returns transaction receipt information</p> <p>Dynamic Chain Handling: - Automatically obtains Web3 instance for the correct blockchain using permit.chain_id - Constructs RPC URL with infrastructure key handling (premium RPC if available, fallback to public) - No chain configuration needed beyond what's in the permit</p> <p>Note: This method should only be called after verify_signature() confirms validity. No additional validation is performed here to avoid redundant blockchain queries.</p> <p>Parameters:</p> Name Type Description Default <code>permit</code> <code>EIP2612Permit</code> <p>EIP2612Permit instance with valid signature (EIP2612Permit)</p> required <p>Returns:</p> Name Type Description <code>EVMTransactionConfirmation</code> <code>EVMTransactionConfirmation</code> <p>Transaction execution result with: - status: Transaction execution status (SUCCESS, FAILED, etc.) - tx_hash: Transaction hash on blockchain - block_number: Block containing transaction - block_timestamp: Block timestamp - gas_used: Actual gas consumed - confirmations: Number of block confirmations - error_message: Error details if execution failed - transaction_fee: Fee paid in wei</p> Note <p>All errors are returned in the result object, no exceptions raised.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.get_balance","title":"<code>get_balance(address: str, token_address: Optional[str] = None, web3: Optional[AsyncWeb3] = None) -&gt; int</code>  <code>async</code>","text":"<p>Query token balance for an address on-chain.</p> <p>This method is designed to work in two modes: 1. With explicit parameters (token_address and web3) - for internal use 2. With just address - for external API use (not recommended without context)</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Wallet address to query (0x-prefixed hex format)</p> required <code>token_address</code> <code>Optional[str]</code> <p>Token contract address (optional, for explicit chain/token context)</p> <code>None</code> <code>web3</code> <code>Optional[AsyncWeb3]</code> <p>AsyncWeb3 instance (optional, created dynamically if not provided)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Token balance in smallest units (0 if address has no balance or error occurs)</p> Note <p>When called from external code without token_address and web3, the method cannot determine which chain to query. Consider refactoring external calls to provide these parameters explicitly.</p>"},{"location":"reference/#x402_mock.adapters.EVMAdapter.get_wallet_address","title":"<code>get_wallet_address() -&gt; str</code>","text":"<p>Get server wallet address from private key.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Server wallet address in checksum format</p>"},{"location":"reference/#x402_mock.adapters.EIP2612PermitSignature","title":"<code>EIP2612PermitSignature</code>","text":"<p>               Bases: <code>BaseSignature</code></p> <p>EIP2612 ECDSA Signature Components.</p> <p>Represents the three components of an ECDSA signature used in EIP2612 permits. These components (v, r, s) are extracted from signing EIP712 typed data and are required to execute the permit() function on EVM smart contracts.</p> <p>Inherits from BaseSignature and implements EVM-specific signature validation.</p> <p>Attributes:</p> Name Type Description <code>signature_type</code> <code>Literal['EIP2612']</code> <p>Always \"EIP2612\" for this implementation</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when the signature was created (inherited from BaseSignature)</p> <code>v</code> <code>int</code> <p>Recovery ID for ECDSA signature recovery (27 or 28)</p> <code>r</code> <code>str</code> <p>X-coordinate of signature point (64 hex characters, may include 0x prefix)</p> <code>s</code> <code>str</code> <p>Y-coordinate of signature point (64 hex characters, may include 0x prefix)</p> Example <p>sig = EIP2612PermitSignature(     signature_type=\"EIP2612\",     v=27,     r=\"0x\" + \"a\" * 64,     s=\"0x\" + \"b\" * 64 ) sig.validate_format()  # Returns True if valid</p>"},{"location":"reference/#x402_mock.adapters.EIP2612PermitSignature.validate_format","title":"<code>validate_format() -&gt; bool</code>","text":"<p>Validate EIP2612 signature format.</p> <p>Checks that all signature components are in valid format for EVM: - v must be 27 or 28 - r and s must be valid hex strings of 64 characters (excluding optional 0x prefix)</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if signature format is valid, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>With descriptive message if validation fails</p> Example <p>try:     sig.validate_format() except ValueError as e:     print(f\"Invalid signature: {e}\")</p>"},{"location":"reference/#x402_mock.adapters.EIP2612Permit","title":"<code>EIP2612Permit</code>","text":"<p>               Bases: <code>BasePermit</code></p> <p>EIP2612 Token Approval Permit.</p> <p>Represents a complete EIP2612 permit for delegated token approval on EVM blockchains. This permit can be used with the permit() function on USDC and other permit-enabled tokens to grant approval without requiring a separate approve() transaction.</p> <p>The permit must be signed by the token owner with an EIP712 signature (recovered from v, r, s).</p> <p>Inherits from BasePermit and adds all EVM-specific permit fields.</p> <p>Attributes:</p> Name Type Description <code>permit_type</code> <code>Literal['EIP2612']</code> <p>Always \"EIP2612\" for this implementation</p> <code>signature</code> <code>EIP2612PermitSignature</code> <p>EIP2612 ECDSA signature components (v, r, s)</p> <code>deadline</code> <code>int</code> <p>Unix timestamp when permit expires (owner must sign before this time)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when permit was created (inherited from BasePermit)</p> <code>owner</code> <code>str</code> <p>Token owner's wallet address (EVM address format: 0x...) (EVM-specific)</p> <code>spender</code> <code>str</code> <p>Address authorized to transfer tokens (typically server address) (EVM-specific)</p> <code>token</code> <code>str</code> <p>Token contract address (e.g., USDC address on specific chain) (EVM-specific)</p> <code>value</code> <code>int</code> <p>Amount of tokens authorized for transfer (in smallest units, e.g., 1e6 for 1 USDC) (EVM-specific)</p> <code>nonce</code> <code>int</code> <p>Unique counter from on-chain state to prevent replay attacks (EVM-specific)</p> <code>chain_id</code> <code>int</code> <p>Blockchain network ID (1=Ethereum, 11155111=Sepolia, etc.) (EVM-specific)</p> Example <p>permit = EIP2612Permit(     permit_type=\"EIP2612\",     owner=\"0x1234...5678\",     spender=\"0x8765...4321\",     token=\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",     value=1000000,  # 1 USDC with 6 decimals     deadline=1704067200,     nonce=0,     chain_id=11155111,     signature=EIP2612PermitSignature(...) )</p>"},{"location":"reference/#x402_mock.adapters.EIP2612Permit.validate_structure","title":"<code>validate_structure() -&gt; bool</code>","text":"<p>Validate EIP2612 permit structure and required fields.</p> <p>Checks that: - All required fields are present and non-empty - Addresses are in valid EVM format (0x...) - Nonce and other numeric fields are non-negative - Signature is present and valid</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if permit structure is valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>With descriptive message if validation fails</p> Example <p>try:     permit.validate_structure() except ValueError as e:     print(f\"Invalid permit: {e}\")</p>"},{"location":"reference/#x402_mock.adapters.EVMPaymentComponent","title":"<code>EVMPaymentComponent</code>","text":"<p>               Bases: <code>BasePaymentComponent</code></p> <p>EVM-Specific Payment Component.</p> <p>Extends BasePaymentComponent with EVM-specific payment requirements including token contract address and chain ID. Typically used for USDC payments on EVM networks (Ethereum, Sepolia, etc.).</p> <p>Attributes:</p> Name Type Description <code>payment_type</code> <code>Literal['evm']</code> <p>Always \"evm\" for this implementation</p> <code>amount</code> <code>float</code> <p>Payment amount for human readability (e.g., 1.0 for 1 USDC)</p> <code>currency</code> <code>str</code> <p>Currency code (typically \"USD\" for stablecoins)</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional payment metadata (may include gas limits, fees, etc.)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when payment component was created</p> <code>token</code> <code>str</code> <p>Token contract address on specific EVM chain (EVM-specific)</p> <code>chain_id</code> <code>int</code> <p>EVM network ID (1=Ethereum, 11155111=Sepolia, etc.) (EVM-specific)</p> Example <p>payment = EVMPaymentComponent(     payment_type=\"evm\",     amount=1.0,  # 1 USDC     currency=\"USD\",     token=\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",     chain_id=11155111,     metadata={\"gas_price\": \"20\", \"priority_fee\": \"2\"} )</p>"},{"location":"reference/#x402_mock.adapters.EVMPaymentComponent.validate_payment","title":"<code>validate_payment() -&gt; bool</code>","text":"<p>Validate EVM payment specification.</p> <p>Checks that: - payment_type is \"evm\"  - amount is non-negative - token is valid EVM address format (0x...) - chain_id is valid EVM network</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payment specification is valid</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>With descriptive message if validation fails</p>"},{"location":"reference/#x402_mock.adapters.EVMVerificationResult","title":"<code>EVMVerificationResult</code>","text":"<p>               Bases: <code>BaseVerificationResult</code></p> <p>EVM-Specific Permit Verification Result.</p> <p>Extends BaseVerificationResult with EVM-specific verification information. Returned by EVMServerAdapter.verify_signature() method.</p> <p>Attributes:</p> Name Type Description <code>verification_type</code> <code>Literal['evm']</code> <p>Always \"evm\" for this implementation</p> <code>status</code> <code>VerificationStatus</code> <p>Verification result status (inherited from BaseVerificationResult)</p> <code>is_valid</code> <code>bool</code> <p>Boolean indicating if verification was successful</p> <code>message</code> <code>str</code> <p>Human-readable status message (inherited from BaseVerificationResult)</p> <code>error_details</code> <code>Optional[Dict[str, Any]]</code> <p>Detailed error information if verification failed (inherited from BaseVerificationResult)</p> <code>verified_at</code> <code>datetime</code> <p>Timestamp when verification was performed (inherited from BaseVerificationResult)</p> <code>permit_owner</code> <code>Optional[str]</code> <p>Verified permit owner address (EVM address)</p> <code>authorized_amount</code> <code>Optional[int]</code> <p>Amount verified as authorized (in smallest units)</p> <code>blockchain_state</code> <code>Optional[Dict[str, Any]]</code> <p>On-chain state data (nonce, allowance, balance, etc.)</p> <code>on_chain_nonce</code> <code>Optional[int]</code> <p>Current on-chain nonce counter for owner</p> <code>on_chain_allowance</code> <code>Optional[int]</code> <p>Current approved allowance amount</p> <code>owner_balance</code> <code>Optional[int]</code> <p>Token balance of owner address</p> Example <p>result = await evm_adapter.verify_signature(permit, payment) if result.is_success():     print(f\"Permit valid. Owner: {result.permit_owner}\") else:     print(f\"Verification failed: {result.get_error_message()}\")</p>"},{"location":"reference/#x402_mock.adapters.EVMTransactionConfirmation","title":"<code>EVMTransactionConfirmation</code>","text":"<p>               Bases: <code>BaseTransactionConfirmation</code></p> <p>EVM-Specific Transaction Confirmation.</p> <p>Extends BaseTransactionConfirmation with EVM-specific transaction receipt data. Returned by EVMServerAdapter.settle() method.</p> <p>Attributes:</p> Name Type Description <code>confirmation_type</code> <code>Literal['evm']</code> <p>Always \"evm\" for this implementation</p> <code>status</code> <code>TransactionStatus</code> <p>Transaction execution status (inherited from BaseTransactionConfirmation)</p> <code>execution_time</code> <code>Optional[float]</code> <p>Time taken to confirm transaction (seconds) (inherited from BaseTransactionConfirmation)</p> <code>confirmations</code> <code>int</code> <p>Number of block confirmations (inherited from BaseTransactionConfirmation)</p> <code>error_message</code> <code>Optional[str]</code> <p>Error details if transaction failed (inherited from BaseTransactionConfirmation)</p> <code>logs</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Transaction logs/events (inherited from BaseTransactionConfirmation)</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when confirmation was recorded (inherited from BaseTransactionConfirmation)</p> <code>tx_hash</code> <code>str</code> <p>Transaction hash (0x-prefixed hex string on EVM)</p> <code>block_number</code> <code>Optional[int]</code> <p>Block number containing transaction</p> <code>block_timestamp</code> <code>Optional[int]</code> <p>Block timestamp (Unix)</p> <code>gas_used</code> <code>Optional[int]</code> <p>Actual gas consumed by transaction</p> <code>gas_limit</code> <code>Optional[int]</code> <p>Gas limit specified for transaction</p> <code>transaction_fee</code> <code>Optional[int]</code> <p>Amount of ETH/native token paid as transaction fee (in wei)</p> <code>from_address</code> <code>Optional[str]</code> <p>Transaction sender address</p> <code>to_address</code> <code>Optional[str]</code> <p>Transaction receiver/contract address</p> Example <p>confirmation = await evm_adapter.settle(permit) if confirmation.is_success():     print(f\"Settlement confirmed: {confirmation.tx_hash}\")     print(f\"Gas used: {confirmation.gas_used}\") else:     print(f\"Settlement failed: {confirmation.error_message}\")</p>"},{"location":"reference/#x402_mock.adapters.get_adapter_type","title":"<code>get_adapter_type(obj: Union[PermitTypes, PaymentComponentTypes, SignatureTypes, VerificationResultTypes, TransactionConfirmationTypes, BasePermit, BasePaymentComponent, BaseVerificationResult, BaseTransactionConfirmation]) -&gt; Optional[str]</code>","text":"<p>Retrieve the unified adapter type identifier for a given permit, payment component,  signature, verification result, or transaction confirmation.</p> <p>Automatically extracts the type discriminator field (permit_type, payment_type,  signature_type, verification_type, or confirmation_type) from the object and returns  the standardized adapter type string that can be used as a key in  AdapterHub._adapter_factories.</p> <p>This function maps all blockchain-specific discriminator values to their unified adapter type identifiers (e.g., \"EIP2612\" -&gt; \"evm\", \"polygon\" -&gt; \"evm\", \"spl\" -&gt; \"svm\").</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[PermitTypes, PaymentComponentTypes, SignatureTypes, VerificationResultTypes, TransactionConfirmationTypes, BasePermit, BasePaymentComponent, BaseVerificationResult, BaseTransactionConfirmation]</code> <p>A permit, payment component, signature, verification result, or transaction  confirmation instance containing a type discriminator field. Supports both   typed instances and base classes.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The unified adapter type string (e.g., \"evm\", \"svm\") that corresponds to</p> <code>Optional[str]</code> <p>the object's blockchain type. Returns None if no matching adapter type is found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # EIP-2612 permit maps to \"evm\"\n&gt;&gt;&gt; permit = EIP2612Permit(permit_type=\"EIP2612\", owner=\"0x...\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(permit)  # Returns \"evm\"\n&gt;&gt;&gt; adapter = hub._adapter_factories[adapter_type]\n</code></pre> <pre><code>&gt;&gt;&gt; # EVM payment component maps to \"evm\"\n&gt;&gt;&gt; component = EVMPaymentComponent(payment_type=\"evm\", token=\"0x...\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(component)  # Returns \"evm\"\n&gt;&gt;&gt; adapter = hub._adapter_factories[adapter_type]\n</code></pre> <pre><code>&gt;&gt;&gt; # EVM verification result maps to \"evm\"\n&gt;&gt;&gt; result = EVMVerificationResult(verification_type=\"evm\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(result)  # Returns \"evm\"\n</code></pre> <pre><code>&gt;&gt;&gt; # Polygon payment also maps to \"evm\"\n&gt;&gt;&gt; component = EVMPaymentComponent(payment_type=\"polygon\", ...)\n&gt;&gt;&gt; adapter_type = get_adapter_type(component)  # Returns \"evm\"\n</code></pre> Note <p>The type mapping is lazily initialized on first call to avoid circular imports. To add support for new blockchains, update _initialize_adapter_type_mapping() with new type mappings in ADAPTER_TYPE_MAPPING.</p>"},{"location":"reference/#schemas","title":"Schemas","text":"<p>Base Schema Models and Type System</p> <p>The Schemas module defines the foundational type system and data models that underpin the entire x402_mock framework. It provides RFC8785-compliant Pydantic models for cryptographic operations, abstract base classes ensuring type safety across blockchain implementations, and standardized HTTP protocol message formats.</p> <p>Key Features: - RFC8785 Compliance: Canonical JSON serialization for deterministic signature generation - Type Safety: Pydantic-based validation with comprehensive type hints - Abstract Base Classes: Define contracts for permits, signatures, verification results, and confirmations - Protocol Messages: Standardized HTTP 402 request/response payload schemas - Version Management: Protocol version negotiation and compatibility handling - Blockchain Agnostic: Base models inherited by all blockchain-specific implementations</p> <p>Main Components: - <code>CanonicalModel</code>: RFC8785-compliant base model with deterministic JSON serialization - Abstract types: <code>BasePermit</code>, <code>BaseSignature</code>, <code>BaseVerificationResult</code>, <code>BaseTransactionConfirmation</code> - HTTP protocol: <code>ClientRequestHeader</code>, <code>Server402ResponsePayload</code>, <code>ClientTokenRequest</code>, <code>ServerTokenResponse</code> - Payment models: <code>BasePaymentComponent</code> defining payment requirements - Status enums: <code>VerificationStatus</code>, <code>TransactionStatus</code> - Version handling: <code>ProtocolVersion</code>, <code>SupportedVersions</code></p> <p>Purpose: Serves as the type foundation ensuring consistent data structures and validations across servers, clients, adapters, and engine components.</p>"},{"location":"reference/#x402_mock.schemas","title":"<code>x402_mock.schemas</code>","text":""},{"location":"reference/#x402_mock.schemas.CanonicalModel","title":"<code>CanonicalModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RFC8785-compliant Pydantic base model with canonical JSON serialization.</p> <p>This model ensures consistent, deterministic JSON representation suitable for cryptographic operations, signature verification, and hashing.</p> Features <ul> <li>Automatic conversion of Pydantic objects, enums, and Decimals to standard types</li> <li>Deterministic key sorting in JSON output</li> <li>No extra whitespace for consistent hashing and signature verification</li> <li>RFC8785 compliance for canonical JSON representation</li> </ul> <p>All schema models should inherit from this class to ensure consistent serialization across the system.</p> Example <p>class MyModel(CanonicalModel):     name: str     value: int</p> <p>model = MyModel(name=\"test\", value=123) canonical_json = model.to_canonical_json()  # Guaranteed consistent format</p>"},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_canonical_json","title":"<code>to_canonical_json() -&gt; str</code>","text":"<p>Convert model to RFC8785-compliant canonical JSON string.</p> <p>This method ensures that the JSON representation is: 1. Deterministically ordered (sorted keys) 2. Whitespace-minimal (compact format) 3. Suitable for cryptographic operations</p> <p>The conversion process: 1. model_dump(mode=\"json\") converts Pydantic objects, enums, and Decimals    to standard Python types (str, int, float, etc.) 2. json.dumps with separators and sort_keys ensures RFC8785 compliance</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>RFC8785-compliant JSON string with sorted keys and no extra whitespace.</p> Example <p>model = MyModel(name=\"test\", value=123) json_str = model.to_canonical_json()</p>"},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_canonical_json--returns-nametestvalue123","title":"Returns: '{\"name\":\"test\",\"value\":123}'","text":""},{"location":"reference/#x402_mock.schemas.CanonicalModel.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert model to dictionary representation.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary with all model fields.</p>"},{"location":"reference/#x402_mock.schemas.BaseSignature","title":"<code>BaseSignature</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain signature components.</p> <p>This class defines the interface that all blockchain-specific signature implementations must follow. Different blockchains use different signature formats (e.g., EIP2612 for EVM uses v/r/s, Solana uses 64-byte signature).</p> <p>All concrete signature classes should inherit from this base class and implement the abstract methods to ensure consistent signature handling across the system.</p> <p>Attributes:</p> Name Type Description <code>signature_type</code> <code>str</code> <p>The type of signature (e.g., \"EIP2612\", \"Solana\")</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when the signature was created</p> <p>Methods:</p> Name Description <code>validate_format</code> <p>Check if signature format is valid for the blockchain</p> <code>to_dict</code> <p>Convert signature to dictionary (inherited from CanonicalModel)</p>"},{"location":"reference/#x402_mock.schemas.BaseSignature.validate_format","title":"<code>validate_format() -&gt; bool</code>","text":"<p>Validate the signature format for the specific blockchain.</p> <p>This method should check that all signature components are in valid format for the target blockchain. For example: - EIP2612: Check v is 27 or 28, r and s are 64 hex chars - Solana: Check signature is 64 bytes</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if signature format is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If signature format is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.BasePermit","title":"<code>BasePermit</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain permit/approval mechanisms.</p> <p>A permit is a signed message that authorizes a spender to transfer tokens on behalf of the token owner. Different blockchains implement permits differently (EIP2612 for EVM, etc.).</p> <p>This base class provides the minimal common fields across all permit types. Blockchain-specific implementations should extend this class and add their specific fields such as owner, spender, token, value, and nonce.</p> <p>Attributes:</p> Name Type Description <code>permit_type</code> <code>str</code> <p>Type of permit (e.g., \"EIP2612\", \"Solana\")</p> <code>signature</code> <code>Optional[BaseSignature]</code> <p>Signature components for permit authorization</p> <code>deadline</code> <code>int</code> <p>Unix timestamp when permit expires</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when permit was created</p> <p>Methods:</p> Name Description <code>is_expired</code> <p>Check if permit has expired</p> <code>validate_structure</code> <p>Validate permit structure (blockchain-specific)</p>"},{"location":"reference/#x402_mock.schemas.BasePermit.is_expired","title":"<code>is_expired(current_timestamp: Optional[int] = None) -&gt; bool</code>","text":"<p>Check if the permit has expired.</p> <p>A permit is considered expired if the current time has passed the deadline.</p> <p>Parameters:</p> Name Type Description Default <code>current_timestamp</code> <code>Optional[int]</code> <p>Unix timestamp to check against (default: current time).              If not provided, uses current UTC timestamp.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if permit has expired, False if still valid.</p> Example <p>permit = MyPermit(...) if permit.is_expired():     raise PermitExpiredError(\"Permit has expired\")</p>"},{"location":"reference/#x402_mock.schemas.BasePermit.validate_structure","title":"<code>validate_structure() -&gt; bool</code>","text":"<p>Validate the permit structure and required fields for the blockchain.</p> <p>Should check that all required fields are present and in valid format for the specific blockchain permit type.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if permit structure is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If permit structure is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.BasePaymentComponent","title":"<code>BasePaymentComponent</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for payment requirement specifications.</p> <p>Payment components define what payment is expected: the amount, currency, and any additional payment-related constraints or metadata. Blockchain-specific implementations (e.g., EVM, SVM) should extend this class and add their specific fields such as token addresses.</p> <p>Attributes:</p> Name Type Description <code>payment_type</code> <code>str</code> <p>Type of payment (e.g., \"evm\", \"svm\")</p> <code>amount</code> <code>float</code> <p>Payment amount for human readability</p> <code>currency</code> <code>str</code> <p>Currency code (e.g., \"USD\", \"ETH\")</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional payment-related metadata</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when payment component was created</p>"},{"location":"reference/#x402_mock.schemas.BasePaymentComponent.validate_payment","title":"<code>validate_payment() -&gt; bool</code>","text":"<p>Validate the payment specification.</p> <p>Should check that payment type, amount, and token are valid and compatible with the system requirements.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if payment specification is valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If payment specification is invalid with descriptive message.</p>"},{"location":"reference/#x402_mock.schemas.VerificationStatus","title":"<code>VerificationStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible verification result statuses.</p> <p>Attributes:</p> Name Type Description <code>SUCCESS</code> <p>Permit signature is valid and verification passed</p> <code>INVALID_SIGNATURE</code> <p>Signature is invalid or signer mismatch</p> <code>EXPIRED</code> <p>Permit deadline has passed</p> <code>INSUFFICIENT_ALLOWANCE</code> <p>Authorized amount is insufficient</p> <code>INSUFFICIENT_BALANCE</code> <p>Token balance insufficient for transaction</p> <code>REPLAY_ATTACK</code> <p>Nonce indicates potential replay attack</p> <code>BLOCKCHAIN_ERROR</code> <p>Error querying blockchain state</p> <code>UNKNOWN_ERROR</code> <p>Unexpected error during verification</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult","title":"<code>BaseVerificationResult</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for permit signature verification results.</p> <p>This class encapsulates the result of verifying a permit signature and checking permit validity on-chain. It provides a standard interface for reporting verification status, success/failure details, and diagnostic information.</p> <p>Attributes:</p> Name Type Description <code>verification_type</code> <code>str</code> <p>Type of verification (e.g., \"evm\", \"svm\")</p> <code>status</code> <code>VerificationStatus</code> <p>Verification result status (VerificationStatus enum)</p> <code>is_valid</code> <code>bool</code> <p>Boolean indicating if verification was successful</p> <code>message</code> <code>str</code> <p>Human-readable status message</p> <code>error_details</code> <code>Optional[Dict[str, Any]]</code> <p>Detailed error information if verification failed</p> <code>verified_at</code> <code>datetime</code> <p>Timestamp when verification was performed</p> <p>Methods:</p> Name Description <code>is_success</code> <p>Check if verification was successful</p> <code>get_error_message</code> <p>Get formatted error message</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult.is_success","title":"<code>is_success() -&gt; bool</code>","text":"<p>Check if verification was successful.</p> <p>Convenience method to check if the verification passed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if verification was successful, False otherwise.</p> Example <p>result = await adapter.verify_signature(permit, payment) if result.is_success():     # Proceed with transaction else:     # Handle verification failure</p>"},{"location":"reference/#x402_mock.schemas.BaseVerificationResult.get_error_message","title":"<code>get_error_message() -&gt; Optional[str]</code>","text":"<p>Get formatted error message from verification result.</p> <p>Returns a human-readable error message explaining why verification failed. Returns None if verification was successful.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Error message if verification failed, None if successful.</p> Example <p>if not result.is_success():     error_msg = result.get_error_message()     print(f\"Verification failed: {error_msg}\")</p>"},{"location":"reference/#x402_mock.schemas.TransactionStatus","title":"<code>TransactionStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible transaction execution statuses.</p> <p>Attributes:</p> Name Type Description <code>SUCCESS</code> <p>Transaction executed successfully on-chain</p> <code>FAILED</code> <p>Transaction reverted or failed on-chain</p> <code>PENDING</code> <p>Transaction is pending confirmation</p> <code>INSUFFICIENT_GAS</code> <p>Transaction failed due to insufficient gas</p> <code>TIMEOUT</code> <p>Transaction confirmation timed out</p> <code>NETWORK_ERROR</code> <p>Network error during transaction submission</p> <code>INVALID_TRANSACTION</code> <p>Transaction is malformed or invalid</p> <code>UNKNOWN_ERROR</code> <p>Unexpected error during transaction execution</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation","title":"<code>BaseTransactionConfirmation</code>","text":"<p>               Bases: <code>CanonicalModel</code>, <code>ABC</code></p> <p>Abstract base class for blockchain transaction confirmation/receipt data.</p> <p>This class captures the result of executing a transaction on-chain, including execution status, timing, and confirmation information.</p> <p>Attributes:</p> Name Type Description <code>confirmation_type</code> <code>str</code> <p>Type of confirmation (e.g., \"evm\", \"svm\")</p> <code>status</code> <code>TransactionStatus</code> <p>Transaction execution status (TransactionStatus enum)</p> <code>execution_time</code> <code>Optional[float]</code> <p>Time taken to confirm transaction (in seconds)</p> <code>confirmations</code> <code>int</code> <p>Number of block confirmations</p> <code>error_message</code> <code>Optional[str]</code> <p>Error message if transaction failed</p> <code>logs</code> <code>Optional[List[Dict[str, Any]]]</code> <p>Optional transaction logs/events</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when confirmation was recorded</p> <p>Methods:</p> Name Description <code>is_success</code> <p>Check if transaction executed successfully</p> <code>get_confirmation_status</code> <p>Get human-readable confirmation status</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.is_success","title":"<code>is_success() -&gt; bool</code>","text":"<p>Check if transaction executed successfully on-chain.</p> <p>Returns True if the transaction was executed without errors and achieved the intended state change on the blockchain.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if transaction succeeded, False if failed or pending.</p> Example <p>confirmation = await adapter.send_transaction(permit) if confirmation.is_success():     print(f\"Transaction confirmed: {confirmation.tx_hash}\") else:     print(f\"Transaction failed: {confirmation.error_message}\")</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.get_confirmation_status","title":"<code>get_confirmation_status() -&gt; str</code>","text":"<p>Get human-readable confirmation status message.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable status message describing transaction state.</p> Example <p>status_msg = confirmation.get_confirmation_status()</p>"},{"location":"reference/#x402_mock.schemas.BaseTransactionConfirmation.get_confirmation_status--may-return-transaction-confirmed-with-10-confirmations","title":"May return: \"Transaction confirmed with 10 confirmations\"","text":""},{"location":"reference/#x402_mock.schemas.ClientRequestHeader","title":"<code>ClientRequestHeader</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HTTP request headers sent by client.</p> <p>Attributes:</p> Name Type Description <code>content_type</code> <code>str</code> <p>MIME type of request body (default: application/json).</p> <code>authorization</code> <code>Optional[str]</code> <p>Optional bearer token for authenticated requests.</p>"},{"location":"reference/#x402_mock.schemas.ServerPaymentScheme","title":"<code>ServerPaymentScheme</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Payment scheme configuration for client payment authorization.</p> <p>Describes the specific payment requirements and supported payment methods that the client must fulfill to access the protected resource.</p> <p>Attributes:</p> Name Type Description <code>payment_components</code> <code>List[PaymentComponentTypes]</code> <p>List of supported payment options/requirements.</p> <code>protocol_version</code> <code>str</code> <p>Version of the payment protocol being used.</p>"},{"location":"reference/#x402_mock.schemas.Server402ResponsePayload","title":"<code>Server402ResponsePayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Server response payload for 402 Payment Required status.</p> <p>This is returned by the server when client attempts to access a protected resource without valid authorization. It instructs the client where to submit payment and what payment methods are accepted.</p> <p>Attributes:</p> Name Type Description <code>access_token_endpoint</code> <code>str</code> <p>URL endpoint for POST request to obtain access token.</p> <code>payment_scheme</code> <code>ServerPaymentScheme</code> <p>Payment requirements and accepted payment methods.</p> <code>payment_instruction</code> <code>Optional[str]</code> <p>Optional instruction explaining payment process and endpoint usage.</p>"},{"location":"reference/#x402_mock.schemas.ClientTokenRequest","title":"<code>ClientTokenRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Client request to exchange permit for access token.</p> <p>The client sends this request to the server's access token endpoint after generating a valid permit that authorizes the payment. The server validates the permit and returns an access token if the permit is valid.</p> <p>This request should be sent as POST with JSON body.</p> <p>Attributes:</p> Name Type Description <code>version</code> <code>ProtocalVersion</code> <p>Protocol version of the permit.</p> <code>permit</code> <code>PermitTypes</code> <p>Signed permit authorizing the payment.</p>"},{"location":"reference/#x402_mock.schemas.ServerTokenResponse","title":"<code>ServerTokenResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Server response containing access token and metadata.</p> <p>Returned when server successfully verifies and accepts a client's permit. The access token is used by client to access the protected resource.</p> <p>Attributes:</p> Name Type Description <code>access_token</code> <code>str</code> <p>Bearer token for authenticating subsequent requests.</p> <code>token_type</code> <code>str</code> <p>Type of token (typically \"Bearer\").</p> <code>expires_in</code> <code>Optional[int]</code> <p>Token lifetime in seconds. None means token never expires.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata about the token or authorization.</p>"},{"location":"reference/#engine","title":"Engine","text":"<p>Event-Driven Execution Engine</p> <p>The Engine module implements a sophisticated event-driven architecture for orchestrating payment protocol workflows. It provides a typed event system with an event bus that allows subscribers to hook into the payment lifecycle, monitor execution flow, capture errors, and customize behavior at critical execution points.</p> <p>Key Features: - Typed Event System: Strongly-typed events representing each stage of payment processing - Event Bus: Publish-subscribe pattern for decoupled event handling - Hook Subscription: Use <code>add_hook()</code> to subscribe handlers to specific event types - Event Chain Execution: Sequential event processing with state transitions - Comprehensive Events: Request initialization, token exchange, verification, settlement, errors - Dependency Injection: Clean separation of business logic from infrastructure dependencies - Exception Hierarchy: Rich exception types for granular error handling - Async-Native: Built for asynchronous execution with asyncio support</p> <p>Key Event Types: - <code>RequestInitEvent</code>: Initial request with optional authorization token - <code>RequestTokenEvent</code>: Payment permit submission for token exchange - <code>Http402PaymentEvent</code>: Payment required response with payment schemes - <code>VerifySuccessEvent</code> / <code>VerifyFailedEvent</code>: Signature verification results - <code>SettleSuccessEvent</code> / <code>SettleFailedEvent</code>: On-chain settlement outcomes - <code>TokenIssuedEvent</code>: Successful access token generation - <code>AuthorizationSuccessEvent</code>: Successful request authorization</p> <p>Main Components: - <code>EventBus</code>: Central event dispatcher with subscriber management - <code>EventChain</code>: Orchestrates event sequence execution - <code>Dependencies</code>: Immutable container for shared infrastructure - Typed events: All events inherit from <code>BaseEvent</code> - Custom exceptions: Detailed error types for different failure scenarios</p> <p>Usage Pattern: Developers can subscribe custom handlers to events using <code>event_bus.subscribe(EventType, handler)</code> to intercept events, log transactions, trigger webhooks, or implement custom business logic at any point in the payment flow.</p>"},{"location":"reference/#x402_mock.engine","title":"<code>x402_mock.engine</code>","text":""},{"location":"reference/#x402_mock.engine.BaseEvent","title":"<code>BaseEvent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all events in the system.</p>"},{"location":"reference/#x402_mock.engine.BaseEvent.__repr__","title":"<code>__repr__() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>String representation of the event.</p>"},{"location":"reference/#x402_mock.engine.RequestInitEvent","title":"<code>RequestInitEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>External trigger: Initialize request with token.</p>"},{"location":"reference/#x402_mock.engine.RequestTokenEvent","title":"<code>RequestTokenEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>External trigger: Request access token with payment permit.</p>"},{"location":"reference/#x402_mock.engine.AuthorizationSuccessEvent","title":"<code>AuthorizationSuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Authorization succeeded with verified payload.</p>"},{"location":"reference/#x402_mock.engine.Http402PaymentEvent","title":"<code>Http402PaymentEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment required - 402 response payload.</p>"},{"location":"reference/#x402_mock.engine.VerifySuccessEvent","title":"<code>VerifySuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment verification succeeded.</p>"},{"location":"reference/#x402_mock.engine.VerifyFailedEvent","title":"<code>VerifyFailedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Payment verification failed.</p>"},{"location":"reference/#x402_mock.engine.SettleFailedEvent","title":"<code>SettleFailedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Settlement failed.</p>"},{"location":"reference/#x402_mock.engine.SettleSuccessEvent","title":"<code>SettleSuccessEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Settlement succeeded.</p>"},{"location":"reference/#x402_mock.engine.Dependencies","title":"<code>Dependencies</code>  <code>dataclass</code>","text":"<p>Container for infrastructure dependencies (read-only).</p>"},{"location":"reference/#x402_mock.engine.EventBus","title":"<code>EventBus</code>","text":"<p>Event dispatcher for publishing and subscribing to events.</p>"},{"location":"reference/#x402_mock.engine.EventBus.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize with empty subscribers and hooks.</p>"},{"location":"reference/#x402_mock.engine.EventBus.subscribe","title":"<code>subscribe(event_class: type[BaseEvent], handler: EventHandlerFunc) -&gt; None</code>","text":"<p>Register an async handler for the given event class. Multiple handlers can be subscribed to the same event type and run in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>The event class to subscribe to.</p> required <code>handler</code> <code>EventHandlerFunc</code> <p>The async handler function to call when the event is published.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If handler is not a coroutine function.</p>"},{"location":"reference/#x402_mock.engine.EventBus.hook","title":"<code>hook(event_class: type[BaseEvent], hook_func: EventHookFunc) -&gt; None</code>","text":"<p>Register a hook for the given event class. Hooks are executed before subscribers when the event is dispatched.</p> <p>Parameters:</p> Name Type Description Default <code>event_class</code> <code>type[BaseEvent]</code> <p>The event class to hook into.</p> required <code>hook_func</code> <code>EventHookFunc</code> <p>The hook function to call when the event is published.</p> required"},{"location":"reference/#x402_mock.engine.EventBus.dispatch","title":"<code>dispatch(event: BaseEvent, deps: Dependencies) -&gt; AsyncGenerator[Optional[BaseEvent], None]</code>  <code>async</code>","text":"<p>Dispatch an event to all registered hooks and subscribers. Hooks run first (synchronously in order), then all subscribers run in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BaseEvent</code> <p>The event to dispatch.</p> required <code>deps</code> <code>Dependencies</code> <p>Dependencies container with injected services.</p> required <p>Yields:</p> Type Description <code>AsyncGenerator[Optional[BaseEvent], None]</code> <p>Results from all subscribers as they complete. Yields nothing if no subscribers are registered.</p>"},{"location":"reference/#x402_mock.engine.TokenIssuedEvent","title":"<code>TokenIssuedEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Result: Access token issued after successful verification.</p>"},{"location":"reference/#x402_mock.engine.BreakEvent","title":"<code>BreakEvent</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>BaseEvent</code></p> <p>Internal event to break the event chain.</p>"},{"location":"reference/#x402_mock.engine.EventChain","title":"<code>EventChain</code>","text":"<p>Executes event-driven workflows by chaining event handler results.</p> <p>Supports early return mechanism: when an event matching early_return_on is encountered, execute() returns that event immediately while remaining processing continues in background.</p>"},{"location":"reference/#x402_mock.engine.EventChain.__init__","title":"<code>__init__(event_bus: EventBus, deps: Dependencies) -&gt; None</code>","text":"<p>Initialize event chain executor.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>The event bus to dispatch events through.</p> required <code>deps</code> <code>Dependencies</code> <p>Dependencies container to pass to handlers.</p> required"},{"location":"reference/#x402_mock.engine.EventChain.execute","title":"<code>execute(initial_event: BaseEvent) -&gt; AsyncGenerator[BaseEvent, None]</code>  <code>async</code>","text":"<p>Execute event chain starting from initial event.</p> <p>Returns:</p> Type Description <code>AsyncGenerator[BaseEvent, None]</code> <p>Yields events encountered during chain execution.</p> Note <p>When early return is triggered, subsequent events continue processing  asynchronously in background without blocking the return.</p>"},{"location":"reference/#x402_mock.engine.BaseException","title":"<code>BaseException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root exception class for all project-specific exceptions.</p> <p>All custom exceptions should inherit from this class to enable unified exception handling and centralized error processing.</p>"},{"location":"reference/#x402_mock.engine.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when authentication fails or credentials are invalid.</p> <p>This includes scenarios such as: - Invalid or expired access tokens - Missing authentication headers - Authentication signature verification failure</p>"},{"location":"reference/#x402_mock.engine.PaymentMethodError","title":"<code>PaymentMethodError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when a payment method is invalid or unsupported.</p> <p>This includes scenarios such as: - Unsupported payment type (on-chain vs off-chain mismatch) - Missing required payment method configuration - Payment method not registered on server</p>"},{"location":"reference/#x402_mock.engine.PaymentSignatureError","title":"<code>PaymentSignatureError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when payment signature generation or processing fails.</p> <p>This includes scenarios such as: - Signature format validation failure - Private key access issues - Signature encoding errors</p>"},{"location":"reference/#x402_mock.engine.TokenError","title":"<code>TokenError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Base exception for token-related errors.</p> <p>Parent class for all token validation and management errors.</p>"},{"location":"reference/#x402_mock.engine.TokenExpiredError","title":"<code>TokenExpiredError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a token has expired and is no longer valid.</p> <p>Attributes:</p> Name Type Description <code>expiration_time</code> <p>When the token expired</p>"},{"location":"reference/#x402_mock.engine.InvalidTokenError","title":"<code>InvalidTokenError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a token is invalid or malformed.</p> <p>This includes scenarios such as: - Corrupted token data - Invalid token signature - Unsupported token version</p>"},{"location":"reference/#x402_mock.engine.TokenNotFoundError","title":"<code>TokenNotFoundError</code>","text":"<p>               Bases: <code>TokenError</code></p> <p>Raised when a requested token cannot be found.</p> <p>Typically occurs in token lookup or retrieval operations.</p>"},{"location":"reference/#x402_mock.engine.PaymentVerificationError","title":"<code>PaymentVerificationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Base exception for payment verification failures.</p> <p>Parent class for all errors that occur during payment validation.</p>"},{"location":"reference/#x402_mock.engine.SignatureVerificationError","title":"<code>SignatureVerificationError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when permit signature verification fails.</p> <p>This includes scenarios such as: - Invalid ECDSA signature - Signature from wrong address - Tampered signature data - Signer address mismatch</p> <p>Attributes:</p> Name Type Description <code>permit_type</code> <p>Type of permit being verified</p> <code>signer</code> <p>Expected signer address</p> <code>recovered</code> <p>Actually recovered address from signature</p>"},{"location":"reference/#x402_mock.engine.PermitExpiredError","title":"<code>PermitExpiredError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when a permit has expired and can no longer be executed.</p> <p>The permit deadline has passed on the blockchain.</p> <p>Attributes:</p> Name Type Description <code>deadline</code> <p>The expired permit deadline</p> <code>current_time</code> <p>Current block timestamp</p>"},{"location":"reference/#x402_mock.engine.PermitNonceError","title":"<code>PermitNonceError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when permit nonce is invalid or already used.</p> <p>This protects against replay attacks by ensuring each permit has a unique nonce that increments with each use.</p> <p>Attributes:</p> Name Type Description <code>expected_nonce</code> <p>Nonce expected on-chain</p> <code>provided_nonce</code> <p>Nonce in the permit</p>"},{"location":"reference/#x402_mock.engine.InsufficientFundsError","title":"<code>InsufficientFundsError</code>","text":"<p>               Bases: <code>PaymentVerificationError</code></p> <p>Raised when account balance is insufficient for the payment.</p> <p>This includes scenarios such as: - Token balance less than permit amount - Insufficient gas for transaction execution</p> <p>Attributes:</p> Name Type Description <code>required</code> <p>Amount required</p> <code>available</code> <p>Amount available</p>"},{"location":"reference/#x402_mock.engine.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when configuration is missing or invalid.</p> <p>This includes scenarios such as: - Missing required configuration keys - Invalid configuration values - RPC URL unreachable - Unsupported network configuration</p>"},{"location":"reference/#x402_mock.engine.InvalidTransition","title":"<code>InvalidTransition</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an invalid state transition occurs in event processing.</p> <p>This indicates that the payment state machine received an event that is not valid for the current state.</p> <p>Attributes:</p> Name Type Description <code>current_state</code> <p>Current payment/transaction state</p> <code>event_type</code> <p>Event that triggered the transition</p> <code>message</code> <p>Description of why transition is invalid</p>"},{"location":"reference/#x402_mock.engine.BlockchainInteractionError","title":"<code>BlockchainInteractionError</code>","text":"<p>               Bases: <code>BaseException</code></p> <p>Raised when blockchain interaction (RPC call) fails.</p> <p>This includes scenarios such as: - RPC call timeout - Network connectivity issues - Invalid contract address - Contract call revert</p> <p>Attributes:</p> Name Type Description <code>rpc_method</code> <p>RPC method that was called (e.g., 'eth_call')</p> <code>reason</code> <p>Error reason from blockchain node</p>"},{"location":"reference/#x402_mock.engine.TransactionExecutionError","title":"<code>TransactionExecutionError</code>","text":"<p>               Bases: <code>BlockchainInteractionError</code></p> <p>Raised when blockchain transaction execution fails.</p> <p>This includes scenarios such as: - Transaction reverted on-chain - Out of gas - Invalid transaction parameters - Nonce conflicts</p> <p>Attributes:</p> Name Type Description <code>tx_hash</code> <p>Transaction hash if available</p> <code>revert_reason</code> <p>Reason transaction was reverted</p>"}]}